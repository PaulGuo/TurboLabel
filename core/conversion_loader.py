import os
import getpass
import yaml
from langchain_openai import AzureChatOpenAI
from core.config_loader import load_settings

settings = load_settings()
openai_settings = settings.get("openai", {})
azure_endpoint = openai_settings.get('OPENAI_API_BASE') or getpass.getpass("Enter OpenAI API Base URL: ")
openai_api_version = openai_settings.get('OPENAI_API_VERSION') or getpass.getpass("Enter OpenAI API Version: ")
deployment_name = openai_settings.get('OPENAI_DEPLOYMENT_NAME') or getpass.getpass("Enter OpenAI Deployment Name: ")
openai_api_key = openai_settings.get('OPENAI_API_KEY') or getpass.getpass("Enter OpenAI API Key: ")
openai_api_type = openai_settings.get('OPENAI_API_TYPE') or getpass.getpass("Enter OpenAI API Type (e.g., 'azure' or 'openai'): ")
temperature = openai_settings.get('TEMPERATURE')

if temperature is None:
    temperature = float(getpass.getpass("Enter temperature for API calls (e.g., 0.5): "))

llm = AzureChatOpenAI(
    azure_endpoint = azure_endpoint,
    openai_api_version = openai_api_version,
    deployment_name = deployment_name,
    openai_api_key = openai_api_key,
    openai_api_type = openai_api_type,
    temperature = temperature,
)

def generate_conversion_function(format_type, schema_dir, cache_dir, use_cache):
    """Generate and cache the conversion function"""
    cache_path = os.path.join(cache_dir, 'convertor', f"{format_type}_convertor.py")
    if use_cache and os.path.exists(cache_path):
        print(f"Using cached conversion function from {cache_path}")
        return cache_path

    # Generate conversion function from schema description
    schema_file = os.path.join(schema_dir, f"{format_type}.txt")
    with open(schema_file, "r") as f:
        schema_prompt = f.read()

    prompt = f"""
        You are an expert Python programmer. Your task is to create a Python function that formats annotation data 
        into a specific JSON structure based on the provided schema. 

        ### Function Requirements:
        1. The function should be named **convert_to_json**.
        2. The function will take three parameters:
          - **image_path** (str): Path to the image file being annotated.
          - **image_file** (str): File name of the image, including the extension (e.g., "example.png" or "photo.jpg").
          - **sam_model_name** (str): Name of the SAM model used for annotation.
          - **annotations** (list): A list of dictionaries, each representing a bounding box and mask annotation. 

        3. The **annotations** parameter is a list of dictionaries where each dictionary has the following keys:
          - **id**: A unique identifier for the annotation, generated using `uuid.uuid4()`.
          - **bbox**: A list representing the bounding box in `[x_min, y_min, width, height]` format.
          - **mask**: The mask array generated by the SAM model, converted to a list format.
          - **img_width**: Width of the image being annotated.
          - **img_height**: Height of the image being annotated.
          - **category_id**: An integer representing the category ID of the annotation.
          - **category_name**: The name of the category for the annotation.

        ### Expected Output:
        The function **convert_to_json** should return a JSON-compatible dictionary with the following structure: {schema_prompt}

        ### Additional Requirements:
        Only provide the function implementation code for **convert_to_json** without any additional explanations or comments.
    """

    response = llm.invoke(prompt)
    conversion_code = response.content

    # Cache the conversion function
    os.makedirs(os.path.dirname(cache_path), exist_ok=True)
    with open(cache_path, "w") as f:
        f.write(conversion_code)
    return cache_path